"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.logToConsole = exports.compare = exports.compareObjects = void 0;
const _ = __importStar(require("lodash"));
const returnArgs_1 = require("../models/returnArgs");
/**
 * Compares two objects.
 * @return {boolean} If all the properties in propertiesToCompare parameter are equeal it returns true
 * future operations.
 * @param {object} obj1 First object to compare.
 * @param {object} obj2 Second object to compare.
 * @param {Array<string>} propertiesToCompare Collection of properties to be compare.
 * If propertiesToCompare is not pass all the keys within first object will be compare with second object
 */
const compareObjects = (obj1, obj2, propertiesToCompare = undefined) => {
    if (propertiesToCompare === undefined) {
        propertiesToCompare = Object.keys(obj1);
    }
    //logToConsole("obj1",obj1);
    //logToConsole("obj2",obj2);
    let returnArgs = new returnArgs_1.ReturnArgs(true);
    //logToConsole("returnArgs",returnArgs);
    propertiesToCompare.forEach(property => {
        if ((0, exports.compare)(obj1, obj2, property) == false) {
            returnArgs.setMessage(false, `Object Values does not match for property :${property}`);
        }
    });
    return returnArgs;
};
exports.compareObjects = compareObjects;
/**
 * Compares a property of two objects.
 * @return {boolean} If all the properties in propertiesToCompare parameter are equeal it returns true
 * future operations.
 * @param {object} obj1 First object to compare.
 * @param {object} obj2 Second object to compare.
 * @param {string} property property to compare.
 */
const compare = (obj1, obj2, property) => {
    //console.log(`:${property}-${_.get(obj1,property)}-${_.get(obj2,property)}-${_.get(obj1,property)!=_.get(obj2,property)}`);
    if (_.get(obj1, property) != _.get(obj2, property)) {
        //console.log(`Object Values does not match for property :${property}`);
        return false;
    }
    return true;
};
exports.compare = compare;
/**
* Logs wellformed object into the console.
* future operations.
* @param {string} header display header.
* @param {object} obj2 object to print.
*/
const logToConsole = (header, obj) => {
    console.log(`${header} :${JSON.stringify(obj, null, 3)}`);
};
exports.logToConsole = logToConsole;
